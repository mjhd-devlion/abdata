
	abdata モジュール ver.1.3
	
	・readme(説明書) 兼 specification(仕様書)
	
＠概要
	HSP3のモジュール変数機能を用いて、コンテナを実装してみたモジュールです。
	
	C++のSTLを若干意識しています。全然相手になりませんが (こっちが)。
	
＠内容
	すべてを一括して #include するには、all.asを使用できます。
	( いろいろ無駄なモノもくっついてきますが。 )
	
	・コンテナ
		(構造名)  : (データ構造)
		value     : 汎値 (単)
		pair      : ペア (双)
		list      : リスト
		unor      : 不整列コンテナ (連想配列)
		stack     : スタック
		queue     : キュー
		deque     : 双方向キュー
		tnode     : 木構造 (擬似)
		
		非推奨
		dict      : 辞書
		dlinklist : 双方向連結リスト
		
	・その他
		abelem     : 要素
		
	以下は、内部で使用するモジュールです。
		container  : 汎用コンテナ	// 使用厳禁
		dlinkvalue : 双方向リンクつき要素型
		*_impl.as  : 各種コンテナの実装部分
		mod_*.as
	
＠命名規則
	ファイル名
		コンテナ
			構造名.as
			
		アルゴリズム
			alg_**.as
			
	モジュール空間
		abdata_構造名
		
	メンバ命令・関数
		構造名_関数名
		
		・先頭は小文字。
		・LowerCamelCase (2単語目以降、先頭だけ大文字)。
		
	メンバ変数
		・接頭辞 m を用いる。
	
	＊内部の命名規則について
		モジュールごとに作成時期に差があるため、
		実装部分の命名規則は二転三転しています。
		現在修正作業中……？
	
＠統一関数(interface)
	全モジュールに含まれる、共通の機能があります。
	これにより、どのコンテナを選んでもだいたい同じような使い方が可能です。
	
	・構築
		new
		
		@ newmod と異なり、変数は自動では配列になりません。
		
	・解体
		delete
		
	・要素数
		size()
		count()
		length()
		
		要素の数を返します。上記三つの行う処理は、どれも全く同じです。
		
	・要素の存在
		exists()
		
		要素がないか否かを返します。
		
	・完全消去
		clear
		
		コンテナを初期状態に戻します。
		
		@ 呼び出し元のインスタンスが解体されるわけではありません。
		
	・複写
		copy 複写元
		
		@ 複写元のインスタンスは破壊されません。
		
	・連結
		chain 連結元
		
		@! ただし、要素数が固定である value, pair にはありません。
		@! 順序がないコンテナの場合は、連結ではなく「結合」の処理を行います。
		
	・コンテナ交換
		exchange 交換先
		
		2つのコンテナに格納されているすべての要素を交換します。
		要素に順序がある場合は、順番が守られます。
		@! swap ではありません。
		
	・反復子::初期化
		iterInit
		
		反復子を初期化します。
		@ iter アルゴリズムで使うための命令です。
		
	・反復子::更新
		iterNext()
		
		反復子を更新し、継続するなら it 変数に新しい値を格納して真を返し、
		継続しないなら偽を返します。
		@ iter アルゴリズムで使うための関数です。
		
	＊その他の関数について
		可能な限り、次のような語を使用しています。
		
		要素挿入 -> insert
		要素削除 -> remove
		要素移動 -> move   ( コンテナ内部での位置の変更 )
		要素交換 -> swap   ( 〃 )
		要素設定 -> set    ( 変数使用 : setv )
		要素取得 -> get    ( 命令形式 : getv )
		要素参照 -> dup    ( クローン変数の作成 )
		
	＊操作名称について
		get
			値の複製の取得。
			
		pop
			get と remove を連続して行う処理。
			
			@ pop_front は先頭、pop_back は末尾への操作。
			
		vartype
			値の型の取得。
			
		set
			要素の値を変更する。要素数は変化しない。
			
		push
			要素挿入(insert)。ただし、index を指定しての挿入機能はないことがある。
			push_front は先頭、push_back は末尾への操作。
			
		add
			一般的な、要素の追加。どこに追加されるかはコンテナ依存。
			
			@ex: list では push_back と全く同じ。
			@ex: unor では <key, value> の組の追加を意味する。
			
＠アルゴリズム(algorithm)
	アルゴリズムとは、abdata によって提供される各種コンテナに対して共通した処理
	を行うモジュールやその中の関数です。アルゴリズム関数を提供するファイルには、
	接頭辞 alg_ が付いています。
	
	・反復アルゴリズム (alg_iter)
		他言語での foreach 的な処理です。foreach が予約語なので、この名称に。
		
		IterateBegin コンテナ, 構造名 [, it変数]
			/* 処理 */
		IterateEnd
		
		コンテナの各要素について繰り返し処理を行います。途中で脱出する場合は、
		_break を使用してください。繰り返しの回数は IterateCnt で参照できます。
		
		it 変数は、unor などの連想配列ではキー、それ以外では要素のクローンです。
		
	@ いい訳語ないかなぁ。
	
＠正常動作
	Windows XP sp3 HomeEdition、HSP3.2 での動作を確認しています。
	
＠著作権
	このモジュールに含まれるすべてのファイルの著作権は作者にありますが、
	このモジュールの使用・改変・配布については、自由に誰でも行えるものとします。
	
＠サポート
	・プログラ広場 (http://prograpark.ninja-web.net/)
		作者の上大とかーみが運営する、プログラミング関係のサイトです。
		意見・要望・バグ報告などは、ここの掲示板にどしどし寄せてください。
		
	・上大へのメール
		アドレスを入手するHSP3スクリプト( 超スパム対策 )
			dim chr, 21
				chr( 0) = $75, $65, $64, $61, $69, $5F, $69, $64, $40, $79
				chr(10) = $61, $68, $6F, $6F, $2E, $63, $6F, $2E, $6A, $70, 0
			sdim s, 32
			foreach chr
				poke s, cnt, chr(cnt)
			loop
			objmode 2
			mesbox s, ginfo(12), 25
		;	exec "mailto:" + s, 16	// メーラを起動
			stop
		
＠更新履歴 (開発視点)
＊2011 04/04 (Mon)
	・abAssert を追加し、要素範囲外の時には assert で止まるようにした。
	・swap, move で、要素が2つ未満の時は assert で止まるようにした。
	
＊2011 01/09 (Sun)
	・insert 時に、要素番号が最大要素数を超えている場合、要素の自動拡張を行う
		ようにした。
		
＊2010 10/13 (Wed)
	・インスタンスの実体をすべて abdataInst に格納するようにした。
	・インクルードガード識別子の、abdata を示す ABSTRACT_DATA_STRUECTURE を
		ABDATA にした。
	
＊2010 10/01 (Fri)
	・value を abelem に改名した。
	・コンテナ value を作成した。
	・コンテナ tnode を作成 (というか既に作っていたのを完成させた)。
	・alg_iter で、異なるコンテナの Iterate があると、２種類目で型不一致エラーが
		起きるバグを修正した。
		@ 参照返し関数で、媒介の変数の型が struct (MStr など) と int (list など)
			で食い違うことがあったのが問題だった。
		@ dummy の命令・関数を挟んで、型を実体のに合わせてから使用するようにした。
	・ver 1.3 としてバックアップ。
	
＊2010 07/21 (Wed)
	・*_empty() の返値がいずれも逆だったので、修整した。
	
＊2010 07/19 (Mon)
	・引数の受け渡しや、一時値に VAR_TEMP を使用するのをやめた。
		前者は、ARG_TEMP() でその仮引数専用の変数を作り、それを介すようにし、
		後者は、local 変数を使用するようにした。
		@ 引数を格納した VAR_TEMP が、呼び出し時の他の引数の処理中に書き換わる
			ことがあり、そうした場合、正常な値を引数に渡せない、という問題が
			実際に起きたため。
		@ バグの修正を除いて、これによる動作の変更はない。
		@; any があれば万事解決なのに。
	
＊2010 07/18 (Sun)
	・pair の _assign, _assignv を、_setBoth, _setvBoth に変更した。
	・tree を削除した。
	・諸変更に合わせて、リファレンス (hsファイル) を修整した。
	
＊2010 07/17 (Sat)
	・Container や Pair を Impl と Wrapper に分離し、すべての実体をモジュールの
		内部で管理し、その添字を利用するように変更した。
	・new_Container などの、一時オブジェクトの生成関数を追加した。
	・命令形式の参照化を、dup ではなく clone にした。
	・pair に pair_getvBoth を追加した。
	
＊2010 06/25 (Fri)
	・pair の要素名を <first, second> から <lhs, rhs> に変更した。
	・Container_sort, List_sort を追加。
	
＊2009 10/04 (Sun)
	・vartype 系関数を追加。
	
＊2009 09/04 (Fri)
	・unor のリファレンスを作成。
	・ver 1.2 として公開＆バックアップ。
		今回はリファレンス充実。
		
＊2009 09/03 (Thu)
	・Container_set, Container_setv で、既存の要素の型と設定する値の型が違う場合、
		value の型を dimtype で変換するように修整した。
	・コンテナ unordered (unor) を作成した。速度に頓着しなかったので、非常に低速
		であると思われる。
	・unor のキー検索速度を( たぶん )改善。
	
＊2009 09/02 (Wed)
	・swap に swap_front, swap_back ( 先頭2つ、末尾2つの交換 ) を追加した。
	・要素が2つ以上ないときは、Container_swap や Container_move がなにもしない
		ように修整した。
	・要素の倍化を追加。
		+ Container_double
		+ Container_double_front
		+ Container_double_back
	・deque のリファレンスを作成。
	
＊2009 08/31 (Mon)
	・dictionary を追加。it はキーを表す、という仕様で、参照化ができない状況を
	打破 (?)。
		素直にハッシュ云々やって作った方が早いかもしれないが。
	・List を Container に変更し、List を Container のラッパにした。
		∵ List が pop_back などを持つのはおかしいため。
		また、deque を Container のラッパにし、順序操作系 swap, move などを削除。
	
＊2009 08/30 (Sun)
	・queue のリファレンスを作成。
	・辞書 Dictionary を追加中。Keys, Items に関連する処理ができないため、
		反復子操作ができないという不完全な状態。
		=>> copy, chain もできない。統一関数が実装できないのではねぇ。
	・List に _front, _back 系の関数を多数追加。
		+ get_front
		+ get_back
		+ getv_front
		+ getv_back
		+ pop_front
		+ pop_back
		+ popv_front
		+ popv_back
		+ push_front
		+ push_back
		+ pushv_front
		+ pushv_back
		+ remove_front
		+ remove_back
	・List で、List_set が新規要素の追加を行わないように修整。
		insert 以外の関数で、添字の循環に対応。
		※ insert は新規要素を末尾に追加するために、要素数と等しい値を許可する。
	・双方向キュー Deque を作成。
		List のラッパとして構築。というか、list とほぼ同じ。
	・「要素数」を返す関数に、size だけでなく count、length を統一関数として追加。
	・List で、remove しても内部の配列の要素数は減っていないため、反転操作で無効
		id が有効域に現れてしまうというバグを修正。
		※ insert, remove でも要素数を用いるが、問題ないので修整は保留。
	・Stack, Queue を Deque のラッパにした。
		=>> 制限された List として実装される。
		※でも一部のランダムアクセスが可能……。
		
＊2009 08/29 (Sat)
	・List に 巡回 (逆回転) (rotate_back)、反転 (revese) を追加。
	・stack, list, pair のリファレンスを作成。
	
＊2009 07/29 (Wed)
	・HSP3.2RC1リリースにつき、#defcfunc ... modvar 構造名@ のハックを
		#modcfunc にすべて修整。
	
＊2009 07/28 (Tue)
	・Mo内フォルダのファイルを #include で結合できなかったバグを修正。
		といっても、abdata の中に移動させただけだが。
		なんでだろう……。
	
＊2009 07/11 (Sat)
	・alg_iter.as を追加。IterateBegin 〜 IterateEnd での画一的な反復が可能に。
	・↑に関して、反復子関係の統一関数を追加。
		iterInit   : 反復子の初期化を行う。
		iterNext() : 反復子の更新を行う。継続なら真を返す。
	・IterateBegin~End が入れ子にできなかったバグを修正。
	・Pair_new が定義前に使われていたバグを修正。
	・setv, getv 系関数の引数の順番を「変数, その他……」に統一。
		・List, Queue が大きく影響を受けた。
		・DLList, Pair は変化無し。
	・mod_shiftArrayで、ArrayInsert すると要素が1つ消滅するという、
		初歩的なバグを修正。
	・List で、insert すると midList の番号が midList の要素番号を指すという謎の
		状態になるバグを、要素配列の要素番号を指すように修正。
	・ver.1.1として公開＆バックアップ。
		でも資料不足相変わらず。
	
＊2009 07/09 (Thu)
	・all.as を追加。
	・Stack_pushvar → Stack_pushv の変更に修正し忘れがあったのを直した。
	・List_valid → List_isValid と変更したが、Queue_valid → Queue_isValid は
		修整されていなかった。他のListラッパーも同様。
	・木構造の反復子でトラバースできるようにしようとしたが、断念。
	
＊2009 07/08 (Wed)
	・「＠反復子関数」を追加。
	・この更新履歴を頑張って構築。
	・ver.1.0 として公開＆バックアップ。
		でもリファレンス不足。
	
＊2009 07/07 (Tue)
	・これ(readme)を作成し、abdata をフォルダ化 (前々からの悲願)。
	・統一関数を実装。同時に、公開メンバ関数の統一的な命名規則を導入。
		new, delete, size, clear, copy, chain, exchange
	・木構造を、インスタンスすべてを1つの静的配列で管理するように再実装。
	
＊2009 05/10 (Sun)
	・キューをリストのラッパーとして再実装。
	
＊2009 05/05 (Tue) 〜 05/10の間
	・リストを作成。
	
＊2009 04/12 (Sun)
	・木構造を階層表現に対応させた。
	
＊2009 04/08 (Wed)
	・ペアを作成。
	
＊2008 10/13 (Mon)
	・双方向連結リストを作成。
	・木構造を作成。
	
＊2008 09/06 (Sat)
	・スタックとキューのファイルを分割。
	
＊不明 (2008 09/04 〜 09/06 か？)
	・スタック＋キューを作成 (StrCalcの初回版に使用した、ハズ)。
	
[EOF]
